<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>„Ç≥„É™„Éâ„Éº„É´ - Quoridor</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: 'Segoe UI', 'Hiragino Sans', 'Meiryo', sans-serif;
  background: #1a1a2e;
  color: #eee;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  user-select: none;
}

h1 {
  margin-top: 12px;
  font-size: clamp(18px, 5vw, 28px);
  letter-spacing: clamp(1px, 1vw, 4px);
  color: #e0c068;
  text-shadow: 0 2px 8px rgba(224,192,104,0.3);
}

.info-bar {
  display: flex;
  align-items: center;
  gap: clamp(8px, 3vw, 24px);
  margin: 8px 0 6px;
  font-size: clamp(12px, 3.5vw, 16px);
  width: 100%;
  justify-content: center;
}

.player-info {
  display: flex;
  align-items: center;
  gap: clamp(4px, 1.5vw, 8px);
  padding: clamp(4px, 1.2vw, 6px) clamp(8px, 2.5vw, 16px);
  border-radius: 8px;
  transition: all 0.3s;
}

.player-info.active {
  background: rgba(255,255,255,0.1);
  box-shadow: 0 0 12px rgba(255,255,255,0.15);
}

.player-dot {
  width: clamp(12px, 3vw, 18px);
  height: clamp(12px, 3vw, 18px);
  border-radius: 50%;
  display: inline-block;
  flex-shrink: 0;
}

.p1-color { background: #4a9eff; box-shadow: 0 0 6px rgba(74,158,255,0.5); }
.p2-color { background: #ff6b6b; box-shadow: 0 0 6px rgba(255,107,107,0.5); }

.controls {
  display: flex;
  gap: clamp(6px, 2vw, 10px);
  margin: 6px 0;
  flex-wrap: wrap;
  justify-content: center;
  align-items: flex-start;
  padding: 0 8px;
  width: 100%;
  max-width: 600px;
}

.controls > button {
  padding: clamp(6px, 1.5vw, 8px) clamp(10px, 3vw, 18px);
  border: 2px solid #555;
  border-radius: 8px;
  background: #2a2a4a;
  color: #ddd;
  font-size: clamp(12px, 3vw, 14px);
  cursor: pointer;
  transition: all 0.2s;
  height: clamp(34px, 8vw, 40px);
  white-space: nowrap;
}

.controls > button:hover {
  background: #3a3a5a;
  border-color: #888;
}

.controls > button.active {
  border-color: #e0c068;
  background: #3a3a5a;
  color: #e0c068;
}

.controls > button.mute-btn {
  min-width: 34px;
  font-size: clamp(15px, 4vw, 18px);
  padding: 6px 10px;
}

/* Wall group: clusters wall button + orientation toggle */
.wall-group {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  gap: 0;
  border: 2px solid #555;
  border-radius: 8px;
  overflow: hidden;
  transition: border-color 0.2s;
}

.wall-group.active {
  border-color: #e0c068;
}

.wall-group #btn-wall {
  padding: clamp(6px, 1.5vw, 8px) clamp(10px, 3vw, 18px);
  border: none;
  border-radius: 0;
  background: #2a2a4a;
  color: #ddd;
  font-size: clamp(12px, 3vw, 14px);
  cursor: pointer;
  transition: all 0.2s;
  white-space: nowrap;
  height: clamp(34px, 8vw, 40px);
}

.wall-group #btn-wall:hover {
  background: #3a3a5a;
}

.wall-group.active #btn-wall {
  background: #3a3a5a;
  color: #e0c068;
}

/* Orientation sub-buttons */
.wall-orient {
  display: none;
  border-top: 1px solid #444;
}

.wall-group.active .wall-orient {
  display: flex;
}

.orient-btn {
  flex: 1;
  padding: clamp(4px, 1vw, 5px) clamp(6px, 1.5vw, 8px);
  border: none;
  background: #252545;
  color: #999;
  font-size: clamp(11px, 2.8vw, 13px);
  cursor: pointer;
  transition: all 0.15s;
  white-space: nowrap;
}

.orient-btn:first-child {
  border-right: 1px solid #444;
}

.orient-btn:hover {
  background: #333358;
  color: #ccc;
}

.orient-btn.active {
  background: #3a3a5a;
  color: #e0c068;
  font-weight: bold;
}

/* Board */
.board-container {
  margin: 6px 0 12px;
  position: relative;
}

.board {
  display: grid;
  gap: 0;
  background: #16213e;
  border: 3px solid #e0c068;
  border-radius: 4px;
  padding: 4px;
}

/* Cells */
.cell {
  background: #0f3460;
  border-radius: 3px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: background 0.15s;
  position: relative;
}

.cell:hover {
  background: #1a4a7a;
}

.wall-mode .cell {
  cursor: crosshair;
}

.wall-mode .cell:hover {
  background: #1a3a5a;
}

.cell.valid-move {
  background: rgba(100, 255, 100, 0.15);
  cursor: pointer;
}

.cell.valid-move:hover {
  background: rgba(100, 255, 100, 0.3);
}

.cell.goal-p1 {
  border-top: 2px solid rgba(74, 158, 255, 0.4);
}

.cell.goal-p2 {
  border-bottom: 2px solid rgba(255, 107, 107, 0.4);
}

/* Player pieces */
.piece {
  width: 70%;
  height: 70%;
  border-radius: 50%;
  transition: all 0.2s;
  z-index: 10;
}

.piece.p1 {
  background: radial-gradient(circle at 35% 35%, #7abfff, #4a9eff, #2a6ecf);
  box-shadow: 0 2px 8px rgba(74,158,255,0.5);
}

.piece.p2 {
  background: radial-gradient(circle at 35% 35%, #ff9a9a, #ff6b6b, #cf3a3a);
  box-shadow: 0 2px 8px rgba(255,107,107,0.5);
}

/* Gap elements ‚Äî expand clickable area in wall mode */
.h-gap, .v-gap {
  cursor: pointer;
  transition: background 0.1s;
  border-radius: 1px;
  position: relative;
}

.h-gap::before, .v-gap::before {
  content: '';
  position: absolute;
  z-index: 5;
}

/* Expand horizontal gap hit area vertically */
.h-gap::before {
  top: -8px; bottom: -8px;
  left: 0; right: 0;
}

/* Expand vertical gap hit area horizontally */
.v-gap::before {
  left: -8px; right: -8px;
  top: 0; bottom: 0;
}

.intersection {
  position: relative;
  cursor: pointer;
}

/* Wall previews and placed walls */
.wall-preview {
  background: rgba(224, 192, 104, 0.4) !important;
}

.wall-placed {
  background: #e0c068 !important;
  box-shadow: 0 0 6px rgba(224,192,104,0.5);
}

/* Victory overlay */
.victory-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.7);
  z-index: 100;
  justify-content: center;
  align-items: center;
}

.victory-overlay.show {
  display: flex;
}

.victory-box {
  background: #1a1a2e;
  border: 3px solid #e0c068;
  border-radius: 16px;
  padding: clamp(24px, 6vw, 40px) clamp(24px, 8vw, 60px);
  text-align: center;
  animation: popIn 0.4s ease;
  width: min(90vw, 400px);
}

@keyframes popIn {
  from { transform: scale(0.5); opacity: 0; }
  to { transform: scale(1); opacity: 1; }
}

.victory-box h2 {
  font-size: clamp(22px, 6vw, 32px);
  margin-bottom: 12px;
}

.victory-box .winner-name {
  font-size: clamp(16px, 4.5vw, 24px);
  margin-bottom: 20px;
}

.victory-box button {
  padding: clamp(8px, 2.5vw, 12px) clamp(20px, 6vw, 32px);
  border: 2px solid #e0c068;
  border-radius: 8px;
  background: #2a2a4a;
  color: #e0c068;
  font-size: clamp(14px, 4vw, 18px);
  cursor: pointer;
  transition: all 0.2s;
}

.victory-box button:hover {
  background: #3a3a5a;
}

/* Status message */
.status-msg {
  height: 20px;
  font-size: clamp(11px, 3vw, 14px);
  color: #e0c068;
  margin-bottom: 2px;
}
</style>
</head>
<body>

<h1>QUORIDOR</h1>

<div class="info-bar">
  <div class="player-info active" id="p1-info">
    <span class="player-dot p1-color"></span>
    <span>„Éó„É¨„Ç§„É§„Éº1</span>
    <span>Â£Å: <strong id="p1-walls">10</strong></span>
  </div>
  <div class="player-info" id="p2-info">
    <span class="player-dot p2-color"></span>
    <span>„Éó„É¨„Ç§„É§„Éº2</span>
    <span>Â£Å: <strong id="p2-walls">10</strong></span>
  </div>
</div>

<div class="controls">
  <button id="btn-move" class="active" onclick="setMode('move')">üö∂ ÁßªÂãï</button>
  <div class="wall-group" id="wall-group">
    <button id="btn-wall" onclick="setMode('wall')">üß± Â£ÅÈÖçÁΩÆ</button>
    <div class="wall-orient" id="wall-orient">
      <button id="btn-h" class="orient-btn active" onclick="setOrientation('h')">‚îÅ Ê®™</button>
      <button id="btn-v" class="orient-btn" onclick="setOrientation('v')">‚îÉ Á∏¶</button>
    </div>
  </div>
  <button class="mute-btn" id="btn-mute" onclick="toggleMute()">üîä</button>
  <button onclick="resetGame()">„É™„Çπ„Çø„Éº„Éà</button>
</div>

<div class="status-msg" id="status-msg"></div>

<div class="board-container">
  <div class="board" id="board"></div>
</div>

<div class="victory-overlay" id="victory-overlay">
  <div class="victory-box">
    <h2>üéâ ÂãùÂà©ÔºÅ</h2>
    <div class="winner-name" id="winner-name"></div>
    <button onclick="resetGame()">„ÇÇ„ÅÜ‰∏ÄÂ∫¶„Éó„É¨„Ç§</button>
  </div>
</div>

<script>
// =========================================================
// COORDINATE SYSTEM
// =========================================================
// Board cells: (r, c) where r=0..8, c=0..8
// Player 1 starts at (8,4), goal row = 0
// Player 2 starts at (0,4), goal row = 8
//
// Walls are placed at INTERSECTIONS between cells.
// An intersection (ir, ic) is at the corner between cells
// (ir,ic), (ir,ic+1), (ir+1,ic), (ir+1,ic+1).
// ir = 0..7, ic = 0..7 (8x8 grid of intersections)
//
// A HORIZONTAL wall at intersection (ir, ic):
//   - Blocks vertical movement between rows ir and ir+1
//     at columns ic and ic+1
//   - Visually: lies below cell row ir, spanning cols ic..ic+1
//
// A VERTICAL wall at intersection (ir, ic):
//   - Blocks horizontal movement between cols ic and ic+1
//     at rows ir and ir+1
//   - Visually: lies right of cell col ic, spanning rows ir..ir+1
//
// DOM grid: 17x17 grid (9 cells + 8 gaps per axis)
//   Cell (r,c)         -> grid position (r*2, c*2)
//   H-gap (ir, c)      -> grid position (ir*2+1, c*2)      [between row ir and ir+1, at col c]
//   V-gap (r, ic)      -> grid position (r*2, ic*2+1)      [between col ic and ic+1, at row r]
//   Intersection(ir,ic) -> grid position (ir*2+1, ic*2+1)

const N = 9; // board size
let CELL_PX = 52;
let GAP_PX = 10;

function calcBoardSize() {
  // Board total = 9*cell + 8*gap + padding(8) + border(6)
  // Keep gap/cell ratio ‚âà 10/52
  const margin = 16;
  const overhead = 8 + 6; // padding + border
  const available = Math.min(window.innerWidth - margin, 562) - overhead;
  // available = 9*cell + 8*gap = cell*(9 + 8*(10/52)) = cell*10.538
  CELL_PX = Math.max(28, Math.floor(available / 10.538));
  GAP_PX  = Math.max(4,  Math.round(CELL_PX * 10 / 52));
}

let state, mode, wallOrientation, muted, audioCtx, gameOver;

function initState() {
  state = {
    players: [
      { row: 8, col: 4 },
      { row: 0, col: 4 },
    ],
    walls: [],       // { ir, ic, orient: 'h'|'v' }
    wallCounts: [10, 10],
    turn: 0,         // 0 or 1
  };
  gameOver = false;
}

// =========================================================
// AUDIO (Web Audio API ‚Äî no external files)
// =========================================================
function ctx() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}

function playMove() {
  if (muted) return;
  const c = ctx(), o = c.createOscillator(), g = c.createGain();
  o.connect(g); g.connect(c.destination);
  o.frequency.value = 600; o.type = 'sine';
  g.gain.setValueAtTime(0.15, c.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, c.currentTime + 0.12);
  o.start(c.currentTime); o.stop(c.currentTime + 0.12);
}

function playWall() {
  if (muted) return;
  const c = ctx();
  [[150,'square',0.2,0.2],[80,'sawtooth',0.1,0.15]].forEach(([f,t,v,d]) => {
    const o = c.createOscillator(), g = c.createGain();
    o.connect(g); g.connect(c.destination);
    o.frequency.value = f; o.type = t;
    g.gain.setValueAtTime(v, c.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, c.currentTime + d);
    o.start(c.currentTime); o.stop(c.currentTime + d);
  });
}

function playError() {
  if (muted) return;
  const c = ctx(), o = c.createOscillator(), g = c.createGain();
  o.connect(g); g.connect(c.destination);
  o.frequency.value = 200; o.type = 'square';
  g.gain.setValueAtTime(0.12, c.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, c.currentTime + 0.25);
  o.start(c.currentTime); o.stop(c.currentTime + 0.25);
}

function playVictory() {
  if (muted) return;
  const c = ctx();
  [523,659,784,1047].forEach((f, i) => {
    const o = c.createOscillator(), g = c.createGain();
    o.connect(g); g.connect(c.destination);
    o.frequency.value = f; o.type = 'sine';
    const t = c.currentTime + i * 0.15;
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.15, t + 0.05);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
    o.start(t); o.stop(t + 0.4);
  });
}

function playTurn() {
  if (muted) return;
  const c = ctx(), o = c.createOscillator(), g = c.createGain();
  o.connect(g); g.connect(c.destination);
  o.frequency.value = 1200; o.type = 'sine';
  g.gain.setValueAtTime(0.08, c.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, c.currentTime + 0.08);
  o.start(c.currentTime); o.stop(c.currentTime + 0.08);
}

// =========================================================
// WALL BLOCKING LOGIC
// =========================================================

// Does any wall in the given list block movement from (r1,c1) to (r2,c2)?
function blocked(r1, c1, r2, c2, walls) {
  const dr = r2 - r1, dc = c2 - c1;
  for (const w of walls) {
    if (w.orient === 'h') {
      // Horizontal wall at intersection (ir, ic) blocks moving between
      // row ir and row ir+1 at columns ic and ic+1
      if (dr === -1 && dc === 0) {
        // moving up: from row r1 to r1-1. Blocked if ir+1 == r1 => ir = r1-1
        // and c1 is ic or ic+1
        if (w.ir === r1 - 1 && (c1 === w.ic || c1 === w.ic + 1)) return true;
      }
      if (dr === 1 && dc === 0) {
        // moving down: from row r1 to r1+1. Blocked if ir == r1
        if (w.ir === r1 && (c1 === w.ic || c1 === w.ic + 1)) return true;
      }
    }
    if (w.orient === 'v') {
      // Vertical wall at intersection (ir, ic) blocks moving between
      // col ic and col ic+1 at rows ir and ir+1
      if (dc === -1 && dr === 0) {
        // moving left: from col c1 to c1-1. Blocked if ic+1 == c1 => ic = c1-1
        if (w.ic === c1 - 1 && (r1 === w.ir || r1 === w.ir + 1)) return true;
      }
      if (dc === 1 && dr === 0) {
        // moving right: from col c1 to c1+1. Blocked if ic == c1
        if (w.ic === c1 && (r1 === w.ir || r1 === w.ir + 1)) return true;
      }
    }
  }
  return false;
}

function getValidMoves(pi) {
  const p = state.players[pi], o = state.players[1 - pi];
  const moves = [];
  for (const [dr, dc] of [[-1,0],[1,0],[0,-1],[0,1]]) {
    const nr = p.row + dr, nc = p.col + dc;
    if (nr < 0 || nr >= N || nc < 0 || nc >= N) continue;
    if (blocked(p.row, p.col, nr, nc, state.walls)) continue;

    if (nr === o.row && nc === o.col) {
      // Jump over opponent
      const jr = nr + dr, jc = nc + dc;
      if (jr >= 0 && jr < N && jc >= 0 && jc < N && !blocked(nr, nc, jr, jc, state.walls)) {
        moves.push({ row: jr, col: jc });
      } else {
        // Diagonal jumps
        const sides = dr === 0 ? [[-1,0],[1,0]] : [[0,-1],[0,1]];
        for (const [sdr, sdc] of sides) {
          const sr = nr + sdr, sc = nc + sdc;
          if (sr >= 0 && sr < N && sc >= 0 && sc < N && !blocked(nr, nc, sr, sc, state.walls)) {
            moves.push({ row: sr, col: sc });
          }
        }
      }
    } else {
      moves.push({ row: nr, col: nc });
    }
  }
  return moves;
}

// BFS: can player pi reach their goal row given a set of walls?
function hasPath(pi, walls) {
  const p = state.players[pi], goal = pi === 0 ? 0 : 8;
  const vis = Array.from({length: N}, () => Array(N).fill(false));
  const q = [p]; vis[p.row][p.col] = true;
  while (q.length) {
    const {row, col} = q.shift();
    if (row === goal) return true;
    for (const [dr, dc] of [[-1,0],[1,0],[0,-1],[0,1]]) {
      const nr = row + dr, nc = col + dc;
      if (nr < 0 || nr >= N || nc < 0 || nc >= N || vis[nr][nc]) continue;
      if (blocked(row, col, nr, nc, walls)) continue;
      vis[nr][nc] = true;
      q.push({row: nr, col: nc});
    }
  }
  return false;
}

// Can a wall be placed at intersection (ir, ic) with given orientation?
function canPlace(ir, ic, orient) {
  if (ir < 0 || ir > 7 || ic < 0 || ic > 7) return false;

  for (const w of state.walls) {
    // Exact duplicate
    if (w.ir === ir && w.ic === ic && w.orient === orient) return false;
    // Same orientation overlap (shares a segment)
    if (orient === 'h' && w.orient === 'h' && w.ir === ir && Math.abs(w.ic - ic) === 1) return false;
    if (orient === 'v' && w.orient === 'v' && w.ic === ic && Math.abs(w.ir - ir) === 1) return false;
    // Cross at same intersection
    if (w.ir === ir && w.ic === ic && w.orient !== orient) return false;
  }

  // Path check
  const test = [...state.walls, { ir, ic, orient }];
  return hasPath(0, test) && hasPath(1, test);
}

// =========================================================
// BUILD BOARD DOM
// =========================================================
function buildBoard() {
  const board = document.getElementById('board');
  board.innerHTML = '';

  const tracks = [];
  for (let i = 0; i < N; i++) {
    tracks.push(CELL_PX + 'px');
    if (i < N - 1) tracks.push(GAP_PX + 'px');
  }
  board.style.gridTemplateColumns = tracks.join(' ');
  board.style.gridTemplateRows = tracks.join(' ');

  // 17x17 grid positions
  for (let gr = 0; gr < 17; gr++) {
    for (let gc = 0; gc < 17; gc++) {
      const rowEven = gr % 2 === 0, colEven = gc % 2 === 0;
      const div = document.createElement('div');

      if (rowEven && colEven) {
        // Cell
        const r = gr >> 1, c = gc >> 1;
        div.className = 'cell';
        div.dataset.r = r; div.dataset.c = c;
        if (r === 0) div.classList.add('goal-p1');
        if (r === 8) div.classList.add('goal-p2');
        div.onclick = () => onCellClick(r, c);
        div.onmouseenter = () => onCellHover(r, c);
        div.onmouseleave = clearPreview;
      } else if (rowEven && !colEven) {
        // V-gap: between col ic and ic+1 at row r
        const r = gr >> 1, ic = (gc - 1) >> 1;
        div.className = 'v-gap';
        div.dataset.r = r; div.dataset.ic = ic;
        div.onclick = () => onGapClick(r, ic, 'v');
        div.onmouseenter = () => onGapHover(r, ic, 'v');
        div.onmouseleave = clearPreview;
      } else if (!rowEven && colEven) {
        // H-gap: between row ir and ir+1 at col c
        const ir = (gr - 1) >> 1, c = gc >> 1;
        div.className = 'h-gap';
        div.dataset.ir = ir; div.dataset.c = c;
        div.onclick = () => onGapClick(ir, c, 'h');
        div.onmouseenter = () => onGapHover(ir, c, 'h');
        div.onmouseleave = clearPreview;
      } else {
        // Intersection
        const ir = (gr - 1) >> 1, ic = (gc - 1) >> 1;
        div.className = 'intersection';
        div.dataset.ir = ir; div.dataset.ic = ic;
        div.onclick = () => onIntersectionClick(ir, ic);
        div.onmouseenter = () => onIntersectionHover(ir, ic);
        div.onmouseleave = clearPreview;
      }

      board.appendChild(div);
    }
  }
}

// =========================================================
// RENDER
// =========================================================
function render() {
  // Clear
  document.querySelectorAll('.piece').forEach(e => e.remove());
  document.querySelectorAll('.valid-move').forEach(e => e.classList.remove('valid-move'));
  document.querySelectorAll('.wall-placed').forEach(e => e.classList.remove('wall-placed'));

  // Pieces
  state.players.forEach((p, i) => {
    const cell = document.querySelector(`.cell[data-r="${p.row}"][data-c="${p.col}"]`);
    if (cell) {
      const d = document.createElement('div');
      d.className = `piece p${i+1}`;
      cell.appendChild(d);
    }
  });

  // Walls
  for (const w of state.walls) {
    paintWall(w.ir, w.ic, w.orient, 'wall-placed');
  }

  // Valid moves
  if (mode === 'move' && !gameOver) {
    for (const m of getValidMoves(state.turn)) {
      const cell = document.querySelector(`.cell[data-r="${m.row}"][data-c="${m.col}"]`);
      if (cell) cell.classList.add('valid-move');
    }
  }

  // Info
  document.getElementById('p1-walls').textContent = state.wallCounts[0];
  document.getElementById('p2-walls').textContent = state.wallCounts[1];
  document.getElementById('p1-info').classList.toggle('active', state.turn === 0);
  document.getElementById('p2-info').classList.toggle('active', state.turn === 1);
}

// Paint / unpaint wall DOM elements for a wall at (ir, ic, orient)
function paintWall(ir, ic, orient, cls) {
  if (orient === 'h') {
    // H-wall spans: h-gap at (ir, ic) and h-gap at (ir, ic+1), plus intersection (ir, ic)
    const g1 = document.querySelector(`.h-gap[data-ir="${ir}"][data-c="${ic}"]`);
    const g2 = document.querySelector(`.h-gap[data-ir="${ir}"][data-c="${ic + 1}"]`);
    const ix = document.querySelector(`.intersection[data-ir="${ir}"][data-ic="${ic}"]`);
    if (g1) g1.classList.add(cls);
    if (g2) g2.classList.add(cls);
    if (ix) ix.classList.add(cls);
  } else {
    // V-wall spans: v-gap at (ir, ic) and v-gap at (ir+1, ic), plus intersection (ir, ic)
    const g1 = document.querySelector(`.v-gap[data-r="${ir}"][data-ic="${ic}"]`);
    const g2 = document.querySelector(`.v-gap[data-r="${ir + 1}"][data-ic="${ic}"]`);
    const ix = document.querySelector(`.intersection[data-ir="${ir}"][data-ic="${ic}"]`);
    if (g1) g1.classList.add(cls);
    if (g2) g2.classList.add(cls);
    if (ix) ix.classList.add(cls);
  }
}

// =========================================================
// EVENT HANDLERS
// =========================================================
function onCellClick(r, c) {
  if (gameOver) return;

  // In wall mode, clicking a cell tries to place a wall nearby
  if (mode === 'wall') {
    onCellClickWallMode(r, c);
    return;
  }

  const mv = getValidMoves(state.turn).find(m => m.row === r && m.col === c);
  if (!mv) { playError(); showStatus('„Åù„Åì„Å´„ÅØÁßªÂãï„Åß„Åç„Åæ„Åõ„Çì'); return; }

  state.players[state.turn].row = r;
  state.players[state.turn].col = c;
  playMove();

  if (r === (state.turn === 0 ? 0 : 8)) {
    gameOver = true;
    render();
    playVictory();
    setTimeout(() => {
      const name = state.turn === 0 ? '„Éó„É¨„Ç§„É§„Éº1 (Èùí)' : '„Éó„É¨„Ç§„É§„Éº2 (Ëµ§)';
      document.getElementById('winner-name').textContent = name;
      document.getElementById('winner-name').style.color = state.turn === 0 ? '#4a9eff' : '#ff6b6b';
      document.getElementById('victory-overlay').classList.add('show');
    }, 300);
    return;
  }
  nextTurn();
}

// Clicking a cell in wall mode: try to find a good wall near this cell
function onCellClickWallMode(r, c) {
  console.log(`[WALL] Cell click: (${r},${c}), orient=${wallOrientation}, walls remaining=${state.wallCounts[state.turn]}`);
  if (state.wallCounts[state.turn] <= 0) { playError(); showStatus('Â£Å„ÅåÊÆã„Å£„Å¶„ÅÑ„Åæ„Åõ„Çì'); return; }
  const orient = wallOrientation;

  // Generate candidate intersections around this cell
  // A cell (r,c) has 4 adjacent intersections: (r-1,c-1), (r-1,c), (r,c-1), (r,c)
  const candidates = [];
  if (orient === 'h') {
    // Horizontal wall: prefer intersections above (r-1,*) and below (r,*) the cell
    candidates.push([r-1, c-1], [r-1, c], [r, c-1], [r, c]);
  } else {
    // Vertical wall: prefer intersections to the left (*, c-1) and right (*, c)
    candidates.push([r-1, c-1], [r, c-1], [r-1, c], [r, c]);
  }

  for (const [ir, ic] of candidates) {
    const ok = canPlace(ir, ic, orient);
    console.log(`  candidate (${ir},${ic}) ${orient}: ${ok}`);
    if (ok) {
      placeWall(ir, ic, orient);
      return;
    }
  }
  playError(); showStatus('„Åù„Åì„Å´„ÅØÂ£Å„ÇíÈÖçÁΩÆ„Åß„Åç„Åæ„Åõ„Çì');
}

// Clicking a gap: figure out the best wall to place there
function onGapClick(idx, idx2, gapType) {
  console.log(`[WALL] Gap click: gapType=${gapType}, idx=${idx}, idx2=${idx2}, mode=${mode}, orient=${wallOrientation}`);
  if (mode !== 'wall' || gameOver) return;
  if (state.wallCounts[state.turn] <= 0) { playError(); showStatus('Â£Å„ÅåÊÆã„Å£„Å¶„ÅÑ„Åæ„Åõ„Çì'); return; }

  const orient = wallOrientation;

  if (gapType === 'h') {
    // H-gap at (ir=idx, c=idx2). This gap sits between row ir and row ir+1 at col c.
    const ir = idx;
    if (orient === 'h') {
      // Try intersection (ir, idx2) then (ir, idx2-1)
      if (canPlace(ir, idx2, 'h')) { placeWall(ir, idx2, 'h'); return; }
      if (canPlace(ir, idx2 - 1, 'h')) { placeWall(ir, idx2 - 1, 'h'); return; }
    } else {
      // Vertical wall near this h-gap. Closest intersections: (ir, idx2-1) and (ir, idx2), (ir-1, idx2-1), (ir-1, idx2)
      if (canPlace(ir, idx2 - 1, 'v')) { placeWall(ir, idx2 - 1, 'v'); return; }
      if (canPlace(ir, idx2, 'v')) { placeWall(ir, idx2, 'v'); return; }
      if (canPlace(ir - 1, idx2 - 1, 'v')) { placeWall(ir - 1, idx2 - 1, 'v'); return; }
      if (canPlace(ir - 1, idx2, 'v')) { placeWall(ir - 1, idx2, 'v'); return; }
    }
  } else {
    // V-gap at (r=idx, ic=idx2). This gap sits between col ic and col ic+1 at row r.
    const ic = idx2;
    if (orient === 'v') {
      // Try intersection (idx, ic) then (idx-1, ic)
      if (canPlace(idx, ic, 'v')) { placeWall(idx, ic, 'v'); return; }
      if (canPlace(idx - 1, ic, 'v')) { placeWall(idx - 1, ic, 'v'); return; }
    } else {
      // Horizontal wall near this v-gap. Closest intersections: (idx-1, ic), (idx, ic), (idx-1, ic-1), etc.
      if (canPlace(idx - 1, ic, 'h')) { placeWall(idx - 1, ic, 'h'); return; }
      if (canPlace(idx, ic, 'h')) { placeWall(idx, ic, 'h'); return; }
      if (canPlace(idx - 1, ic - 1, 'h')) { placeWall(idx - 1, ic - 1, 'h'); return; }
      if (canPlace(idx, ic - 1, 'h')) { placeWall(idx, ic - 1, 'h'); return; }
    }
  }
  playError(); showStatus('„Åù„Åì„Å´„ÅØÂ£Å„ÇíÈÖçÁΩÆ„Åß„Åç„Åæ„Åõ„Çì');
}

// Clicking an intersection: place wall centered on it
function onIntersectionClick(ir, ic) {
  if (mode !== 'wall' || gameOver) return;
  if (state.wallCounts[state.turn] <= 0) { playError(); showStatus('Â£Å„ÅåÊÆã„Å£„Å¶„ÅÑ„Åæ„Åõ„Çì'); return; }
  if (canPlace(ir, ic, wallOrientation)) { placeWall(ir, ic, wallOrientation); return; }
  // Try the other orientation as fallback
  const alt = wallOrientation === 'h' ? 'v' : 'h';
  if (canPlace(ir, ic, alt)) { placeWall(ir, ic, alt); return; }
  playError(); showStatus('„Åù„Åì„Å´„ÅØÂ£Å„ÇíÈÖçÁΩÆ„Åß„Åç„Åæ„Åõ„Çì');
}

function placeWall(ir, ic, orient) {
  console.log(`[WALL] === PLACED wall at (${ir},${ic}) orient=${orient} ===`);
  state.walls.push({ ir, ic, orient });
  state.wallCounts[state.turn]--;
  playWall();
  nextTurn();
}

// Hover preview
function onGapHover(idx, idx2, gapType) {
  if (mode !== 'wall' || gameOver) return;
  clearPreview();
  const orient = wallOrientation;
  let wir, wic;

  if (gapType === 'h') {
    const ir = idx;
    if (orient === 'h') {
      if (canPlace(ir, idx2, 'h')) { wir = ir; wic = idx2; }
      else if (canPlace(ir, idx2 - 1, 'h')) { wir = ir; wic = idx2 - 1; }
      else return;
    } else {
      if (canPlace(ir, idx2 - 1, 'v')) { wir = ir; wic = idx2 - 1; }
      else if (canPlace(ir, idx2, 'v')) { wir = ir; wic = idx2; }
      else if (canPlace(ir - 1, idx2 - 1, 'v')) { wir = ir - 1; wic = idx2 - 1; }
      else if (canPlace(ir - 1, idx2, 'v')) { wir = ir - 1; wic = idx2; }
      else return;
    }
  } else {
    const ic = idx2;
    if (orient === 'v') {
      if (canPlace(idx, ic, 'v')) { wir = idx; wic = ic; }
      else if (canPlace(idx - 1, ic, 'v')) { wir = idx - 1; wic = ic; }
      else return;
    } else {
      if (canPlace(idx - 1, ic, 'h')) { wir = idx - 1; wic = ic; }
      else if (canPlace(idx, ic, 'h')) { wir = idx; wic = ic; }
      else if (canPlace(idx - 1, ic - 1, 'h')) { wir = idx - 1; wic = ic - 1; }
      else if (canPlace(idx, ic - 1, 'h')) { wir = idx; wic = ic - 1; }
      else return;
    }
  }
  paintWall(wir, wic, orient, 'wall-preview');
}

function onCellHover(r, c) {
  if (mode !== 'wall' || gameOver) return;
  clearPreview();
  const orient = wallOrientation;
  const candidates = orient === 'h'
    ? [[r-1, c-1], [r-1, c], [r, c-1], [r, c]]
    : [[r-1, c-1], [r, c-1], [r-1, c], [r, c]];
  for (const [ir, ic] of candidates) {
    if (canPlace(ir, ic, orient)) {
      paintWall(ir, ic, orient, 'wall-preview');
      return;
    }
  }
}

function onIntersectionHover(ir, ic) {
  if (mode !== 'wall' || gameOver) return;
  clearPreview();
  if (canPlace(ir, ic, wallOrientation)) {
    paintWall(ir, ic, wallOrientation, 'wall-preview');
  }
}

function clearPreview() {
  document.querySelectorAll('.wall-preview').forEach(e => e.classList.remove('wall-preview'));
}

// =========================================================
// GAME FLOW
// =========================================================
function nextTurn() {
  state.turn = 1 - state.turn;
  playTurn();
  showStatus('');
  render();
}

function showStatus(msg) {
  document.getElementById('status-msg').textContent = msg;
  if (msg) setTimeout(() => {
    const el = document.getElementById('status-msg');
    if (el.textContent === msg) el.textContent = '';
  }, 2000);
}

function setMode(m) {
  mode = m;
  document.getElementById('btn-move').classList.toggle('active', m === 'move');
  document.getElementById('wall-group').classList.toggle('active', m === 'wall');
  document.body.classList.toggle('wall-mode', m === 'wall');
  clearPreview();
  render();
}

function setOrientation(o) {
  wallOrientation = o;
  document.getElementById('btn-h').classList.toggle('active', o === 'h');
  document.getElementById('btn-v').classList.toggle('active', o === 'v');
  clearPreview();
}

function toggleMute() {
  muted = !muted;
  document.getElementById('btn-mute').textContent = muted ? 'üîá' : 'üîä';
}

function resetGame() {
  document.getElementById('victory-overlay').classList.remove('show');
  initState();
  mode = 'move';
  wallOrientation = 'h';
  document.getElementById('btn-move').classList.add('active');
  document.getElementById('wall-group').classList.remove('active');
  document.getElementById('btn-h').classList.add('active');
  document.getElementById('btn-v').classList.remove('active');
  document.body.classList.remove('wall-mode');
  showStatus('');
  render();
}

// =========================================================
// INIT
// =========================================================
mode = 'move';
wallOrientation = 'h';
muted = false;
audioCtx = null;
gameOver = false;
initState();
calcBoardSize();
buildBoard();
render();

// Rebuild board on resize (orientation change on mobile etc.)
let resizeTimer;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(() => {
    calcBoardSize();
    buildBoard();
    render();
  }, 150);
});
</script>
</body>
</html>
